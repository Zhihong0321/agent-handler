<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Tester Chat</title>
  <style>
    :root {
      --bg: #0f172a;
      --header: #1e293b;
      --input-bg: #1e293b;
      --text: #f1f5f9;
      --accent: #38bdf8;
      --bubble-user: #0ea5e9;
      --bubble-bot: #334155;
      --border: #334155;
      --muted: #94a3b8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100%;
      width: 100%;
      overflow: hidden; /* Prevent body scroll */
    }
    /* Views Container - Absolute to guarantee full size */
    .view-container {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      background: var(--bg);
      overflow: hidden;
    }
    /* Drawer */
    .drawer {
      position: fixed; top: 0; left: 0; bottom: 0; width: 280px;

      background: var(--header); z-index: 20;
      transform: translateX(-100%); transition: transform 0.3s ease;
      box-shadow: 2px 0 10px rgba(0,0,0,0.5);
      display: flex; flex-direction: column;
    }
    .drawer.open { transform: translateX(0); }
    .drawer-header { padding: 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
    .drawer-content { flex: 1; overflow-y: auto; padding: 10px; }
    .overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6); z-index: 15;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .overlay.open { opacity: 1; pointer-events: auto; }

    /* Header */
    header {
      background: var(--header);
      padding: 12px 16px;
      display: flex; align-items: center; justify-content: space-between;
      border-bottom: 1px solid var(--border);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      flex: 0 0 auto; /* Prevent header from shrinking */
    }
    .menu-btn { font-size: 24px; cursor: pointer; background: none; border: none; color: var(--text); padding: 0; }
    .agent-info { font-size: 16px; font-weight: 600; text-align: center; flex: 1; }
    .feedback-btn { color: var(--accent); background: none; border: 1px solid var(--accent); border-radius: 6px; padding: 4px 8px; font-size: 12px; cursor: pointer; }

    /* Chat Area */
    main { 
      flex: 1; /* Standard flex grow */
      overflow-y: auto; 
      padding: 16px; 
      display: flex; 
      flex-direction: column; 
      gap: 12px;
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
      position: relative;
    }
    .bubble {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 15px;
      line-height: 1.4;
      word-wrap: break-word;
      position: relative;
      flex-shrink: 0; /* Prevent bubbles from being squashed */
    }
    .bubble.user {
      align-self: flex-end;
      background: var(--bubble-user);
      color: white;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      align-self: flex-start;
      background: var(--bubble-bot);
      color: var(--text);
      border-bottom-left-radius: 4px;
    }
    .bubble.bot strong {
      color: #38bdf8;
      font-weight: 600;
    }
    .bubble.bot .citation {
      color: var(--muted);
      font-size: 11px;
      background: rgba(255,255,255,0.1);
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(56,189,248,0.2);
    }
    
    /* Input Area */
    footer {
      background: var(--header);
      padding: 10px;
      padding-bottom: max(10px, env(safe-area-inset-bottom));
      display: flex; gap: 10px;
      border-top: 1px solid var(--border);
      flex: 0 0 auto; /* Prevent footer from shrinking */
      position: relative; /* Ensure z-index works if needed */
      z-index: 10;
      min-height: 66px; /* Enforce minimum height */
    }
    textarea {
      flex: 1;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 10px 14px;
      color: var(--text);
      resize: none;
      height: 44px;
      font-family: inherit;
      font-size: 15px;
    }
    textarea:disabled { opacity: 0.5; cursor: not-allowed; }
    textarea:focus { outline: none; border-color: var(--accent); }
    .send-btn {
      background: var(--accent);
      color: #0f172a;
      border: none;
      border-radius: 50%;
      width: 44px; height: 44px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      font-weight: bold;
      transition: opacity 0.2s;
    }
    .send-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .send-btn.loading {
        background: var(--border);
        color: transparent;
        position: relative;
    }
    .send-btn.loading::after {
        content: "";
        position: absolute;
        top: 50%; left: 50%;
        width: 16px; height: 16px;
        margin: -8px 0 0 -8px;
        border: 2px solid var(--text);
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* Thread List Items */
    .thread-item {
      padding: 12px; border-bottom: 1px solid var(--border);
      cursor: pointer;
    }
    .thread-item:active { background: rgba(255,255,255,0.05); }
    .thread-title { font-size: 14px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .thread-date { font-size: 11px; color: var(--muted); margin-top: 4px; }
    .new-chat-btn {
      width: 100%; padding: 12px; margin-bottom: 10px;
      background: var(--accent); color: #0f172a;
      border: none; border-radius: 8px; font-weight: 600;
      cursor: pointer;
    }

    /* Feedback Modal */
    dialog {
      background: var(--header); color: var(--text);
      border: 1px solid var(--border); border-radius: 12px;
      width: 90%; max-width: 320px;
      padding: 0;
    }
    dialog::backdrop { background: rgba(0,0,0,0.7); }
    .modal-body { padding: 20px; display: flex; flex-direction: column; gap: 10px; }
    .modal-body textarea, .modal-body input {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }
    .modal-body textarea:focus, .modal-body input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .modal-actions { display: flex; gap: 10px; margin-top: 10px; }
    .btn { padding: 10px 16px; border-radius: 6px; border: none; flex: 1; cursor: pointer; font-weight: 600; font-size: 14px; }
    .btn-primary { background: var(--accent); color: #0f172a; }
    .btn-secondary { background: var(--border); color: var(--text); }
    .btn:hover { opacity: 0.9; }
    .btn:active { transform: scale(0.98); }
  </style>
</head>
<body>

  <!-- Views -->
  <div id="dashboard-view" class="view-container" style="display:flex; padding:20px;">
      <h2 style="text-align:center; margin-bottom:30px; flex-shrink:0;" id="dash-agent-name">Agent Tester</h2>
      
      <button class="new-chat-btn" id="dash-new-chat" style="padding:20px; font-size:16px; margin-bottom:30px; background:linear-gradient(135deg, #38bdf8, #0ea5e9); color:#0f172a; border:none; border-radius:16px; font-weight:bold; box-shadow:0 10px 25px rgba(56,189,248,0.25); flex-shrink:0;">
          + Start New Test Scenario
      </button>
      
      <h4 style="color:var(--muted); text-transform:uppercase; font-size:12px; letter-spacing:1px; margin-bottom:15px; flex-shrink:0;">Previous Scenarios</h4>
      <div id="dash-thread-list" style="flex:1; overflow-y:auto; display:flex; flex-direction:column; gap:10px; min-height:0;">
          <!-- Populated by JS -->
      </div>
  </div>

  <div id="chat-view" class="view-container" style="display:none;">
      <header>
        <button class="menu-btn" id="back-to-dash" style="font-size:18px; font-weight:bold;">‚Üê</button>
        <div class="agent-info" id="chat-title">Untitled</div>
        <div style="display:flex; gap:8px;">
            <button class="menu-btn" id="delete-thread-btn" style="font-size:18px; color:var(--muted);" title="Delete Thread">üóëÔ∏è</button>
            <button class="feedback-btn" id="feedback-btn">Feedback</button>
        </div>
      </header>

      <main id="chat-box">
        <!-- Bubbles -->
      </main>

      <footer id="input-area">
        <textarea id="message-input" placeholder="Type a message..."></textarea>
        <button class="send-btn" id="send-btn">></button>
      </footer>
  </div>

  <!-- Feedback Modal -->
  <dialog id="feedback-modal">
    <div class="modal-body">
      <h3 style="margin-top:0;">Thread Feedback</h3>
      <p style="font-size: 13px; color: var(--muted); margin-bottom:10px;">Leave a comment about this conversation for the admin.</p>
      <textarea id="feedback-text" style="height: 100px; resize:vertical; min-height:60px; max-height:200px;" placeholder="E.g. Great answer, but missed the context..."></textarea>
      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancel-feedback">Cancel</button>
        <button class="btn btn-primary" id="submit-feedback">Submit</button>
      </div>
    </div>
  </dialog>
  
  <!-- Rename Modal -->
  <dialog id="rename-modal">
    <div class="modal-body">
      <h3 style="margin-top:0;">Rename Chat</h3>
      <input id="rename-input" placeholder="New chat title..." />
      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancel-rename">Cancel</button>
        <button class="btn btn-primary" id="submit-rename">Save</button>
      </div>
    </div>
  </dialog>

  <script>
    // --- State & Config ---
    const urlParams = new URLSearchParams(window.location.search);
    const config = {
      agentId: urlParams.get('agentId'),
      mode: urlParams.get('mode') || 'auto',
      sources: urlParams.get('sources') || 'web',
      model: urlParams.get('model') || '',
    };

    // Generate or retrieve Tester ID
    let testerId = localStorage.getItem('tester_id');
    if (!testerId) {
      testerId = 'tester-' + Math.random().toString(36).slice(2, 10);
      localStorage.setItem('tester_id', testerId);
    }

    let currentThreadUuid = null;
    let threads = [];
    
    // Sound Effects
    const sounds = {
        send: new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA='), // Placeholder, will use real short blip
        receive: new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=')
    };
    
    // Real simple beeps generated via AudioContext instead of loading files to save bandwidth
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        if (type === 'send') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        } else {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
        }
    }

    // --- Elements ---
    const els = {
      // Views
      dashboardView: document.getElementById('dashboard-view'),
      chatView: document.getElementById('chat-view'),
      
      // Dashboard
      dashAgentName: document.getElementById('dash-agent-name'),
      dashNewChat: document.getElementById('dash-new-chat'),
      dashThreadList: document.getElementById('dash-thread-list'),
      
      // Chat
      chatTitle: document.getElementById('chat-title'),
      backToDash: document.getElementById('back-to-dash'),
      chatBox: document.getElementById('chat-box'),
      input: document.getElementById('message-input'),
      sendBtn: document.getElementById('send-btn'),
      feedbackBtn: document.getElementById('feedback-btn'),
      
      // Modals
      feedbackModal: document.getElementById('feedback-modal'),
      feedbackText: document.getElementById('feedback-text'),
      cancelFeedback: document.getElementById('cancel-feedback'),
      submitFeedback: document.getElementById('submit-feedback'),
      renameModal: document.getElementById('rename-modal'),
      renameInput: document.getElementById('rename-input'),
      cancelRename: document.getElementById('cancel-rename'),
      submitRename: document.getElementById('submit-rename'),
      deleteThreadBtn: document.getElementById('delete-thread-btn'),
    };

    // --- Init ---
    async function init() {
      if (!config.agentId) {
        alert('No Agent ID provided in URL.');
        return;
      }
      // Load Agent Info
      try {
        const res = await fetch('/api/agents');
        const data = await res.json();
        const agent = (data.agents || []).find(a => a.id === config.agentId);
        if (agent) {
          els.dashAgentName.textContent = `${agent.name} Tester`;
        }
      } catch (e) { console.error(e); }

      await loadThreads();
      
      // Check if we have a saved active thread
      const lastThread = localStorage.getItem('last_thread_uuid_' + config.agentId);
      if (lastThread && threads.find(t => t.thread_uuid === lastThread)) {
          switchThread(lastThread);
      } else {
          showDashboard();
      }
    }
    
    // --- View Management ---
    function showDashboard() {
        els.dashboardView.style.display = 'flex';
        els.chatView.style.display = 'none';
        loadThreads(); // Refresh list
    }
    
    function showChat(title) {
        els.dashboardView.style.display = 'none';
        els.chatView.style.display = 'flex';
        els.chatTitle.textContent = title || 'Untitled';
    }
    
    els.backToDash.onclick = () => {
        currentThreadUuid = null;
        localStorage.removeItem('last_thread_uuid_' + config.agentId);
        showDashboard();
    };

    els.deleteThreadBtn.onclick = async () => {
        if (!currentThreadUuid) return;
        if (!confirm("Are you sure you want to delete this thread? This action cannot be undone.")) return;
        
        try {
            const res = await fetch('/api/tester/threads/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ testerId, threadUuid: currentThreadUuid })
            });
            if (res.ok) {
                // Success: Return to dashboard
                currentThreadUuid = null;
                localStorage.removeItem('last_thread_uuid_' + config.agentId);
                showDashboard();
            } else {
                alert("Failed to delete thread");
            }
        } catch (err) {
            alert("Error deleting thread");
        }
    };

    // --- Threads ---
    async function loadThreads() {
      try {
        const res = await fetch(`/api/tester/threads?testerId=${testerId}`);
        const data = await res.json();
        threads = data.threads || [];
        renderThreads();
      } catch (err) { console.error('Failed to load threads', err); }
    }

    function renderThreads() {
      els.dashThreadList.innerHTML = '';
      if (!threads.length) {
          els.dashThreadList.innerHTML = '<div style="padding:20px; color:var(--muted); text-align:center; font-size:14px; background:rgba(255,255,255,0.03); border-radius:12px;">No test history.<br>Start a new scenario above.</div>';
          return;
      }
      threads.forEach(t => {
        const div = document.createElement('div');
        div.className = 'thread-item';
        div.style.background = 'rgba(255,255,255,0.05)';
        div.style.borderRadius = '12px';
        div.style.marginBottom = '0';
        div.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center;">
             <div class="thread-title" style="flex:1; font-size:15px;">${t.title || 'Untitled Thread'}</div>
             <button class="menu-btn" style="font-size:14px; padding:8px; color:var(--muted);" onclick="event.stopPropagation(); openRename('${t.thread_uuid}', \`${(t.title||'').replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`)">‚úé</button>
          </div>
          <div class="thread-date">${new Date(t.updated_at).toLocaleString()}</div>
        `;
        div.onclick = () => switchThread(t.thread_uuid, t.title);
        els.dashThreadList.appendChild(div);
      });
    }

    window.openRename = (uuid, currentTitle) => {
        els.renameInput.dataset.uuid = uuid;
        els.renameInput.value = currentTitle || 'Untitled Thread';
        els.renameModal.showModal();
        setTimeout(() => els.renameInput.focus(), 100);
    };
    
    els.cancelRename.onclick = () => els.renameModal.close();
    els.submitRename.onclick = async () => {
        const uuid = els.renameInput.dataset.uuid;
        const newTitle = els.renameInput.value.trim();
        if (!uuid || !newTitle) return;
        
        try {
            await fetch('/api/tester/threads/rename', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ testerId, threadUuid: uuid, title: newTitle })
            });
            // Update local list
            const t = threads.find(x => x.thread_uuid === uuid);
            if (t) t.title = newTitle;
            if (currentThreadUuid === uuid) els.chatTitle.textContent = newTitle;
            renderThreads();
            els.renameModal.close();
        } catch (err) {
            alert('Failed to rename');
        }
    };

    async function loadMessages(threadUuid) {
        if (!threadUuid) return;
        try {
            const res = await fetch(`/api/messages/${threadUuid}`);
            const data = await res.json();
            if (data.messages) {
                els.chatBox.innerHTML = ''; // Clear current view
                if (data.messages.length === 0) {
                    els.chatBox.innerHTML = '<div style="text-align: center; color: var(--muted); margin-top: 40px; font-size: 14px;">Start chatting...</div>';
                } else {
                    data.messages.forEach(m => {
                        // Map roles to UI classes
                        const role = m.role === 'user' ? 'user' : 'bot';
                        if (m.role === 'system') return; // Skip system prompts
                        appendBubble(m.content, role);
                    });
                }
            }
        } catch (err) {
            console.error('Failed to load messages', err);
        }
    }

    async function switchThread(uuid, title) {
        if (currentThreadUuid === uuid && els.chatView.style.display !== 'none') return;
        
        currentThreadUuid = uuid;
        const t = threads.find(x => x.thread_uuid === uuid);
        showChat(title || (t ? t.title : 'Untitled'));
        
        els.chatBox.innerHTML = '<div style="text-align:center; padding:20px; color:var(--muted)">Loading history...</div>';
        
        // Load messages
        await loadMessages(uuid);
        
        // Restore session on backend
        await fetch(`/api/session/${testerId}/thread`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ frontendContextUuid: uuid })
        });
        
        // Persist current thread
        localStorage.setItem('last_thread_uuid_' + config.agentId, uuid);
    }

    els.dashNewChat.onclick = async () => {
        const name = prompt("Enter a name for this test scenario (e.g. 'Angry Customer'):");
        if (!name) return; // Cancelled

        const newUuid = crypto.randomUUID ? crypto.randomUUID() : `thread-${Date.now()}`;
        
        // 1. Create thread entry immediately with the name
        try {
            const res = await fetch('/api/tester/threads/rename', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ testerId, threadUuid: newUuid, title: name })
            });
            if (!res.ok) throw new Error('Failed to create thread');
        } catch(e) { 
            alert("Error creating thread. Please try again.");
            return; 
        }

        // 2. Reset backend session
        await fetch(`/api/session/${testerId}/thread`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ frontendContextUuid: newUuid, backendUuid: null })
        });

        // 3. Switch to view (manually set empty state)
        currentThreadUuid = newUuid;
        localStorage.setItem('last_thread_uuid_' + config.agentId, newUuid);
        showChat(name);
        els.chatBox.innerHTML = `<div style="text-align: center; color: var(--muted); margin-top: 40px; font-size: 14px;">Scenario: <strong>${name}</strong><br>Start chatting...</div>`;
    };

    // --- Messaging ---
    function appendBubble(text, role) {
        const div = document.createElement('div');
        div.className = `bubble ${role}`;
        // Preserve markup language (HTML, markdown, etc.)
        if (text.includes('**') || text.includes('*') || text.includes('[') || text.includes('<')) {
            // Contains markup - render as HTML (convert markdown-like formatting)
            let html = text
                // Bold: **text** -> <strong>text</strong>
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // Italic: *text* -> <em>text</em>
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                // Citations: [cite_start]...[cite: 5] -> <span class="citation">...</span>
                .replace(/\[cite_start\](.*?)\[cite:\s*(\d+)\]/g, '<span class="citation" title="Citation $2">$1</span>')
                // Double line breaks -> paragraph breaks
                .replace(/\n\n/g, '</p><p>')
                // Single line breaks
                .replace(/\n/g, '<br>')
                // Wrap in paragraphs
                .replace(/^(?!<p>)/, '<p>')
                .replace(/(?<!<\/p>)$/, '</p>');
            div.innerHTML = html;
        } else {
            // Plain text
            div.textContent = text;
        }
        els.chatBox.appendChild(div);
        els.chatBox.scrollTop = els.chatBox.scrollHeight;
    }

    async function sendMessage() {
        const text = els.input.value.trim();
        if (!text) return;
        
        // Prevent spam / double submit
        if (els.sendBtn.disabled) return;

        // UI Updates
        appendBubble(text, 'user');
        els.input.value = '';
        els.input.disabled = true;
        els.sendBtn.disabled = true;
        els.sendBtn.classList.add('loading');
        els.sendBtn.textContent = ''; // Hide arrow
        playSound('send');
        
        const payload = {
            customerId: testerId,
            message: text,
            agentId: config.agentId,
            mode: config.mode,
            sources: config.sources,
            model: config.model,  // Add model parameter
            frontendContextUuid: currentThreadUuid || undefined
        };
        
        try {
            const res = await fetch('/api/message', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await res.json();
            
            if (data.error) {
                appendBubble('Error: ' + data.error, 'bot');
            } else {
                appendBubble(data.reply, 'bot');
                playSound('receive');
            }
            
            // Update thread ID if new
            if (data.session && data.session.frontendContextUuid) {
                if (currentThreadUuid !== data.session.frontendContextUuid) {
                    currentThreadUuid = data.session.frontendContextUuid;
                    loadThreads(); // Refresh list to show new thread
                    // Auto-prompt for name after short delay
                    setTimeout(() => {
                        if (confirm('Would you like to name this new chat thread?')) {
                            openRename(currentThreadUuid, '');
                        }
                    }, 1500);
                }
            }
        } catch (err) {
            appendBubble('Network Error', 'bot');
        } finally {
            // Reset UI
            els.input.disabled = false;
            els.sendBtn.disabled = false;
            els.sendBtn.classList.remove('loading');
            els.sendBtn.textContent = '>';
            els.input.focus();
        }
    }
    
    els.sendBtn.onclick = sendMessage;
    els.input.onkeypress = (e) => { 
      if(e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    };

    // --- Feedback ---
    els.feedbackBtn.onclick = () => {
        if (!currentThreadUuid) {
            alert("Start a chat first to leave feedback on it.");
            return;
        }
        els.feedbackModal.showModal();
    };
    els.cancelFeedback.onclick = () => els.feedbackModal.close();
    
    els.submitFeedback.onclick = async () => {
        const content = els.feedbackText.value.trim();
        if (!content) return;
        
        try {
            await fetch('/api/feedback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    testerId,
                    threadUuid: currentThreadUuid,
                    content
                })
            });
            alert('Feedback sent!');
            els.feedbackText.value = '';
            els.feedbackModal.close();
        } catch (err) {
            alert('Error sending feedback');
        }
    };

    init();
  </script>
</body>
</html>
